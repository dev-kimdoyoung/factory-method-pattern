# 디자인 패턴
## 정의
- 소프트웨어의 아키텍처를 디자인할 때 자주 발생하는 문제들에 대한 해결책을 일반화
> 예시 : 개발자들에게 One App GUI를 제공하여 클라우드 벤더에 대한 신경을 쓰지 않고 개발할 수 있도록 해주는 플랫폼을 개발
>> 고민 포인트 : 멀티 클라우드에 대한 프로비저닝을 개발하기 위해 각 CSP에 대한 공통 및 개별 기능을 효율적으로 개발하기 위해 디렉터리 구조를 어떻게 가져가야할까?

## 분류
- 생성 패턴 : 기존 코드의 유연성 및 재사용성을 증가시키는 ***객체를 생성***하는데 필요한 디자인 패턴
- 구조 패턴 : 구조를 유연하고 효율적으로 유지하면서 ***객체들과 인터페이스들을 더 큰 구조로 조립***하는 방법을 제공하기 위한 디자인 패턴
- 행동 패턴 : ***객체와 인터페이스 사이의 알고리즘 혹은 책임 분배***를 정리한 디자인 패턴
    - 한 객체가 수행할 수 없는 작업을 어떤 기준으로 여러 개의 객체로 나누어 분배해야 객체 간 결합도가 최소화될지 중점

# 팩토리 메서드 패턴 (Factory Method)
## 정의
- 하나의 객체를 생성할 때 어떤 구조체 (struct)의 인스턴스를 만들지 서브 구조체(struct)에서 결정
- GO는 클래스 및 상속 기능이 없기 때문에 고전적인 팩토리 메서드 패턴 구현은 불가

## Use Case
### 문제
하나의 Bare Metal 장비를 납품하는 여러 벤더들 (dell, supermicro 등)에 대한 표준을 정의하고 기능 함수를 구현
> 구현할 객체들의 유형과 의존 관계를 미리 모르는 경우 사용
>> 복잡성이 낮고 더 많은 커스터마이징이 가능하며 향후 추상 팩토리, 프로토타입 및 빌더 패턴 등으로 발전해나갈 수 있음
>> 추상 팩토리는 결국 팩토리 메소드들의 집합을 기반으로 하는 경우가 많음

### 해결 방안 : 추상 팩토리 패턴
- 공통 구조체 (struct)인 Bare Metal에 저장할 데이터 필드를 정의
- Bare Metal 구조체에서 사용할 함수들을 정의하는 interface (InterfaceBareMetal) 정의
- Bare Metal 구조체에서 interface (InterfaceBareMetal)를 사용할 수 있도록 기능 구현
- 각 벤더 별 struct (dell, supermicro) 정의 및 객체 생성 코드 구현
- 각 벤더 객체를 특정 함수 (GetBareMetal)를 통해서만 생성할 수 있도록 구현

## 장점
- 단일 책임 원칙
- 개방 폐쇄 원칙

## 단점
- 디자인 패턴을 구현하기 위해 많은 자식 클래스 (go 파일을 도입해야할 수 있음)